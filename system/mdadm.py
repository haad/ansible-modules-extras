#!/usr/bin/python
# -*- coding: utf-8 -*-
# (c) 2015, Adam Hamsik <haaaad@gmail.com>
#
# This file is part of Ansible
#
# This module is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this software.  If not, see <http://www.gnu.org/licenses/>.

DOCUMENTATION = '''
---
module: mdadm
version_added: 2.3
short_description: Initialize and manage linux mdadm array
description: Create, Manage linux software raid
requirements: [ python json ]
options:
  state:
    description:
      - Defines action which can be either RAID creation or removal. This will assemble
        existing array if it exist od disks or it will try to create new one if it doesn't.
    choices: [ 'present', 'absent', 'examine', 'scan']
    default: 'present'
    required: false
  level:
    description:
      - type of array to create
    required: true
    default: 1
    choices: ['0', '1', '5', '6']
  md_device:
    description:
      - Raid device path if this is not provided it will be autogenerated.
        When special value auto is used we will use autogenerated md disk name.
    required: false
    default: null
  raid_devices:
    description:
      - List of disk devices to add to RAID.
    required: true
    default: null
  spare_devices:
    description:
      - Number of spare devices in RAID build.
    required: true
    default: 0
  assume_clean:
    description:
      - Assume created array is clean.
    required: false
    default: no
  force:
    description:
      - Force raid creation.
    required: false
    default: no
author: Adam Hamsik <haaaad@gmail.com>
'''

EXAMPLES = '''
mdadm:
  state: present
  level: 1
  md_device: /dev/md0
  raid_devices:
    - /dev/sda
    - /dev/sdb
    - /dev/sdc
  spare_devices: 1
  force: no

mdadm:
  state: present
  level: 5
  md_device: auto
  raid_devices:
    - /dev/sda
    - /dev/sdb

mdadm:
  state: examine
  md_device: /dev/md0

mdadm:
  state: examine
  raid_devices:
    - /dev/sda
    - /dev/sdb

mdadm:
  state: scan
register: list_of_raid_devices_on_system
'''

RETURN = '''
#
'''

# TODO:
#  1) Add support for starting RAID with some missing disks
#  3) It seems that mdadm returns different hash if it creates raid
#       device and when it's already created.
#

RAID_CONF = {
    0:{'min_dev': 1, 'redundancy': 0},
    1:{'min_dev': 2, 'redundancy': 1},
    5:{'min_dev': 3, 'redundancy': 1},
    6:{'min_dev': 4, 'redundancy': 2},
    10:{'min_dev': 4, 'redundancy': 2}
}

class MdManager(object):
    '''
    MDADM raid manager class
    '''
    def __init__(self, module, md_device, level, raid_devices, spares):
        self.module = module
        self.level = level
        self.md_device = md_device
        self.raid_devices = raid_devices
        self.spares = spares

        self.test_mdadm()

    def test_mdadm(self):
        ''' Test if mdadm is actuall executable or not '''
        test_cmd = "mdadm --version"

        (md_rc, del_out, del_err) = self.module.run_command(test_cmd, check_rc=True)

    def test_raid_level_disks_number(self):
        ''' Check if we have proper number of disks for givel RAID level. '''
        if not RAID_CONF.get(self.level, None):
            self.module.fail_json(msg="Unsupported RAID level '%d' used"% self.level, level=self.level)

        min_dev = RAID_CONF[self.level]['min_dev']
        disk_red = 0 #TODO: intentionaly set to 0 until missing disk support is done RAID_CONF[level]['redundancy']

        # Starting Number of devices in RAID Array can be lower that min_dev - redundancy
        if (min_dev - disk_red) > len(self.raid_devices):
            self.module.fail_json(msg="Not enough RAID disks provided '%d' for level '%d', minimum is '%d'"
                                  % (len(self.raid_devices), self.level, (min_dev - disk_red)),
                                  level=self.level, raid_devices=self.raid_devices)

        return True

    def test_raid_disks(self, level, md_device):
        ''' Check if there is a raid superblock already present on given disks '''

        for disk in self.raid_devices:
            test_cmd = "mdadm --examine --test %s" % disk
            (md_rc, md_out, md_err) = self.module.run_command(test_cmd, check_rc=False)

            # if run was successfull it means there is a array on give device and we can't proceed
            if not md_rc:
                disk_info = self.get_raid_info(disk)
                md_info = self.get_md_info(md_device)
                raid_level = disk_info.get('level')

                if raid_level == 'raid%s' % (level):
                    self.module.exit_json(changed=False,
                        msg="Disk device %s already contains raid with same level: %s as requested on md: %s" %
                                          (disk, raid_level, md_device),
                                          disk=disk, md_device=md_device, disk_info=disk_info,
                                          md_info=md_info, array=md_info['devices'])
                else:
                    self.module.fail_json(msg="Disk device '%s' already contains RAID array with level %s" % (disk, raid_level),
                                          disk=disk, stderr=md_err, stdout=md_out, **disk_info)
            elif 'No such file' in md_err:
                self.module.fail_json(msg="Disk device '%s' doesn't exist." % (disk),
                                      disk=disk, stderr=md_err, stdout=md_out)

    def get_raid_info(self, disk):
        ''' Get MD info from given disk '''
        md_cmd = "mdadm --examine --brief --verbose %s" % disk

        (md_rc, md_out, md_err) = self.module.run_command(md_cmd, check_rc=False)

        fix_md_out = md_out.replace('ARRAY ', 'ARRAY=')

        # Return hash containing info about array on a given disk

        if fix_md_out:
            return dict((k, v) for k, v in (item.split('=') for item in fix_md_out.split()))
        else:
            return dict(array='There is no raid array present on %s disk' % disk)

    def get_md_info(self, md_disk):
        ''' Get MD info from given raid disk '''

        if md_disk == 'auto':
            md_cmd = "mdadm --detail --verbose --scan"
        else:
            md_cmd = "mdadm --detail --verbose --brief %s" % md_disk

        (md_rc, md_out, md_err) = self.module.run_command(md_cmd, check_rc=False)

        fix_md_out = md_out.replace('\n   ', ' ').replace('ARRAY ', 'ARRAY=').split('\n')

        md_info = {}
        # Return hash containing info about array on a given disk
        for md_dev in fix_md_out:
            if md_dev:
                md_info = (dict((k.lower(), v) for k, v in (item.split('=') for item in md_dev.split())))
                #md_info[md.get('array')] = md

        # Return hash containing info about array on a given disk
        return md_info

    def get_new_md_device(self):
        ''' On existing system generate new mdadm device name. '''
        md_cmd = "mdadm --detail --scan"

        (md_rc, md_out, md_err) = self.module.run_command(md_cmd, check_rc=False)

        dev_number = len(md_out.split('\n'))

        return "md%d" % (dev_number)

    def create_md_raid(self, force, assume_clean):
        ''' Create md raid with given level on selected disks '''
        force_flag = ' '
        clean_flag = ' '
        dev_name = self.md_device
        dev_list = ' '.join(self.raid_devices)
        spare_param = '--spare-devices %d' % self.spares

        if dev_name == 'auto':
            dev_name = self.get_new_md_device()

        if force:
            force_flag = '--force'

        if assume_clean:
            clean_flag = '--assume-clean'

        if self.level == 0:
            spare_param = ''

        md_cmd = "mdadm --create %s --level %d --raid-devices %d --run %s %s %s %s" % (
            dev_name, self.level, len(self.raid_devices), spare_param,
            force_flag, clean_flag, dev_list)

        (md_rc, md_out, md_err) = self.module.run_command(md_cmd, check_rc=True)

        if md_rc:
            self.module.fail_json(msg="Raid creation failed for device '%s'" % (self.md_device),
                                  raid=self.md_device, error=md_err, stdout=md_out)

    def stop_md_raid(self, force):
        ''' Stop running md raid '''
        force_flag = ' '

        if force:
            force_flag = '--force'

        md_cmd = "mdadm --stop %s %s" % (self.md_device, force_flag)

        (md_rc, md_out, md_err) = self.module.run_command(md_cmd, check_rc=False)

        # If raid odens't exist don't fail module
        if 'No such file' in md_err:
            self.module.exit_json(changed=False, msg="MD device %s is not running" %
                                  (self.md_device))
            return

        # Fail for any other error
        if md_rc:
            self.module.fail_json(msg="Raid device '%s' didn't stop." % (self.md_device),
                                  raid=self.md_device, error=md_err, stdout=md_out)

    def zero_md_raid(self, disk, force):
        ''' Zero superblock on a device '''
        force_flag = ' '

        if force:
            force_flag = '--force'

        md_cmd = "mdadm --zero-superblock %s %s" % (disk, force_flag)

        (md_rc, md_out, md_err) = self.module.run_command(md_cmd, check_rc=True)

        if 'Unrecognised md component device' in md_err:
            self.module.exit_json(changed=False, msg="Disk MD is not a MD device" %
                                  (disk), disk=disk, error=md_err, stdout=md_out)
            return

    def scan_raid_disks(self):
        ''' Scan existing raid disks on a system '''
        md_cmd = "mdadm --detail --scan"

        (md_rc, md_out, md_err) = self.module.run_command(md_cmd, check_rc=False)

        return filter(None, md_out.split('\n'))

def main():
    argument_spec = dict(
        state=dict(required=False, default='present',
                   choices=['present', 'absent', 'examine', 'scan']),
        level=dict(required=False, default=1, choices=[0, 1, 5, 6, 10], type='int'),
        md_device=dict(required=False, type='str'),
        spare_devices=dict(required=False, default=0, type='int'),
        raid_devices=dict(required=False, default=None, type='list'),
        assume_clean=dict(required=False, type='bool'),
        force=dict(required=False, type='bool')
    )

    module = AnsibleModule(
        argument_spec=argument_spec,
    )

    state = module.params.get('state')
    level = module.params.get('level')

    md_device = module.params.get('md_device')
    spare_devices = module.params.get('spare_devices')
    raid_devices = module.params.get('raid_devices')

    assume_clean = module.params.get('assume_clean')
    force = module.params.get('force')

    md = MdManager(module, md_device, level, raid_devices, spare_devices)

    if state == 'examine':
        if md_device:
            module.exit_json(changed=False, **md.get_md_info(md_device))
        elif raid_devices:
            disk_list = []
            for disk in raid_devices:
                disk_list.append(md.get_raid_info(disk))
            module.exit_json(changed=False, **dict(raid_devices=disk_list))
    elif state == 'present':
        if not force:
            md.test_raid_disks(level, md_device)
        md.test_raid_level_disks_number()
        md.create_md_raid(force, assume_clean)
        module.exit_json(changed=True, **md.get_md_info(md_device))
    elif state == 'absent':
        if md_device:
            md.stop_md_raid(force)
        for disk in raid_devices:
            md.zero_md_raid(disk, force)
        module.exit_json(changed=True,
                         msg="Raid device '%s' was removed and wiped from disks '%s'" %
                         (md_device, ' '.join(raid_devices)),
                         md_device=md_device, raid_devices=raid_devices)
    elif state == 'scan':
        module.exit_json(changed=False, md_devices=md.scan_raid_disks())

# import module snippets
from ansible.module_utils.basic import *

if __name__ == "__main__":
    main()
